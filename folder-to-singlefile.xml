<?xml version="1.0" ?>
<folderStructure>
  <folder name="folder-to-singlefile">
    <file name="LICENSE">
      <content>MIT License

Copyright (c) 2024 Talha Orak

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</content>
    </file>
    <folder name="folder2file">
      <file name="config.py">
        <content>"""
Configuration module for folder2file.
"""
from dataclasses import dataclass
from typing import Optional

__version__ = "0.3.6"


@dataclass
class Config:
    """
    Configuration class for folder2file.

    Attributes:
        folder_path: Path to the folder to process
        output_format: Output format (json, markdown, or text)
        no_newline: Whether to remove unnecessary newlines
        skip_binaries: Whether to skip binary file contents
        skip_content: Whether to skip file contents entirely
        include_hidden: Whether to include hidden files and folders
        no_gitignore: Whether to ignore .gitignore rules
        print_output: Whether to print output to console
        out_filename: Output filename
    """
    folder_path: str = "."
    output_format: str = "json"
    no_newline: bool = False
    skip_binaries: bool = True
    skip_content: bool = False
    include_hidden: bool = False
    no_gitignore: bool = False
    print_output: bool = False
    out_filename: Optional[str] = None
</content>
      </file>
      <file name="out_text.py">
        <content>from typing import Dict, List, Any, Optional


def format_text(data: Dict[str, List[Dict[str, Any]]]) -&gt; str:
    """
    Format the data as a plain text string.

    Args:
        data: The data to format

    Returns:
        The formatted text string
    """
    result: List[str] = []
    for folder_name, entries in data.items():
        result.append(f"{folder_name}/")
        for entry in entries:
            result.extend(format_text_entry(entry, 1))
    return "\n".join(result)


def format_text_entry(entry: Dict[str, Any], level: int) -&gt; List[str]:
    """
    Format a single entry in the data as text.

    Args:
        entry: The entry to format
        level: The current indentation level

    Returns:
        A list of strings representing the formatted entry
    """
    result: List[str] = []
    for name, content in entry.items():
        if isinstance(content, list):  # It's a directory
            result.append(f"{'  ' * level}{name}/")
            for sub_entry in content:
                result.extend(format_text_entry(sub_entry, level + 1))
        else:  # It's a file
            result.append(f"{'  ' * level}{name}")
            if content is not None:
                result.append(f"{'  ' * (level + 1)}{content}")
    return result
</content>
      </file>
      <file name="folder_processor.py">
        <content>"""
Module for processing folder structures into dictionary representations.
"""
import os
import base64
from typing import Dict, List, Any, Callable, Union, Optional
from .gitignore_parser import parse_gitignore
from .config import Config


class process_folder:
    """
    Process a folder structure and convert it to a dictionary representation.
    """

    def __init__(self, config: Config):
        """
        Initialize the folder processor with the given configuration.

        Args:
            config: Configuration options for processing
        """
        self.config: Config = config
        self.gitignore_patterns: List[str] = []
        self.result: Dict[str, List[Dict[str, Any]]] = {}
        self.gitignore_matches: Callable[[str], bool]

        gitignore_path: str = os.path.join(config.folder_path, '.gitignore')
        if not config.no_gitignore and os.path.exists(gitignore_path):
            self.gitignore_matches = parse_gitignore(gitignore_path)
        else:
            self.gitignore_matches = lambda x: False

        folder_name: str = os.path.basename(config.folder_path)
        if folder_name == '.':
            folder_name = os.path.basename(os.path.abspath(config.folder_path))
        self.result[folder_name] = self.process_folder(config.folder_path)

    def process_folder(self, folder_path: str) -&gt; List[Dict[str, Any]]:
        """
        Process a folder and its contents recursively.

        Args:
            folder_path: Path to the folder to process

        Returns:
            List of dictionaries representing the folder's contents
        """
        result: List[Dict[str, Any]] = []

        for item in os.listdir(folder_path):
            item_path: str = os.path.join(folder_path, item)
            item_name: str = item
            if os.path.isdir(item_path):
                item_name += '/'
            if not self.config.include_hidden and item.startswith('.'):
                continue

            if not self.config.no_gitignore and self.gitignore_matches(item_path):
                continue

            if os.path.isfile(item_path):
                result.append(
                    self.process_file(item, item_path))
            elif os.path.isdir(item_path):
                item_name = os.path.basename(item_path)
                result.append({
                    item_name:
                    self.process_folder(item_path)
                })

        return result

    def process_file(self, file_name: str, file_path: str) -&gt; Dict[str, Optional[str]]:
        """
        Process a file and its contents.

        Args:
            file_name: Name of the file
            file_path: Path to the file

        Returns:
            Dictionary with file name as key and content (or None) as value
        """
        if is_binary(file_path) and self.config.skip_binaries:
            return {file_name: None}

        if self.config.skip_content:
            return {file_name: None}

        try:
            with open(file_path, 'rb') as file:
                content: bytes = file.read()
                if is_binary(file_path):
                    return {file_name: base64.b64encode(content).decode('utf-8')}
                else:
                    return {file_name: content.decode('utf-8')}
        except Exception as e:
            return {file_name: f"Error reading file: {str(e)}"}


def is_binary(file_path: str) -&gt; bool:
    """
    Check if a file is binary or text.

    Args:
        file_path: Path to the file to check

    Returns:
        True if the file is binary, False otherwise
    """
    try:
        with open(file_path, 'tr') as check_file:
            check_file.read()
            return False
    except:
        return True
</content>
      </file>
      <file name="out_json.py">
        <content>import json
from typing import Dict, Any


def format_json(data: Dict[str, Any], no_newline: bool) -&gt; str:
    """
    Format the data as a JSON string.

    Args:
        data: The data to format
        no_newline: Whether to remove newlines from the output

    Returns:
        The formatted JSON string
    """
    if no_newline:
        return json.dumps(data, separators=(',', ':'))
    return json.dumps(data, indent=2)
</content>
      </file>
      <file name="__init__.py">
        <content>"""
folder2file package for converting folder structures to various formats.
"""
# First, import version and Config from config
from .config import __version__, Config

# Then import everything else
from .out_json import format_json
from .out_md import format_markdown
from .out_text import format_text
from .out_xml import format_xml

# Import process_folder last to avoid circular dependencies
from .folder_processor import process_folder

__all__ = [
    'Config',
    'process_folder',
    'format_json',
    'format_markdown',
    'format_text',
    'format_xml',
    '__version__',
]
</content>
      </file>
      <file name="out_xml.py">
        <content>"""
Module for formatting folder structure as XML.
"""
import xml.dom.minidom
import xml.etree.ElementTree as ET
from typing import Dict, Any, Optional


def format_xml(data: Dict[str, Any], no_newline: bool) -&gt; str:
    """
    Format the folder structure as XML.

    Args:
        data: The folder structure data to format
        no_newline: Whether to remove unnecessary newlines from file contents

    Returns:
        The formatted XML string
    """
    root = ET.Element("folderStructure")

    # Process each top-level folder
    for folder_name, entries in data.items():
        folder_elem = ET.SubElement(root, "folder", name=folder_name)
        process_entries(folder_elem, entries, no_newline)

    # Convert to string with proper formatting
    rough_string = ET.tostring(root, 'utf-8')
    reparsed = xml.dom.minidom.parseString(rough_string)
    return reparsed.toprettyxml(indent="  ")


def process_entries(parent_elem: ET.Element, entries: list, no_newline: bool) -&gt; None:
    """
    Process entries recursively and add them to the parent element.

    Args:
        parent_elem: The parent XML element
        entries: List of entries to process
        no_newline: Whether to remove unnecessary newlines
    """
    for entry in entries:
        for name, content in entry.items():
            if isinstance(content, list):  # It's a directory
                folder_elem = ET.SubElement(parent_elem, "folder", name=name)
                process_entries(folder_elem, content, no_newline)
            else:  # It's a file
                file_elem = ET.SubElement(parent_elem, "file", name=name)
                if content is not None:
                    content_elem = ET.SubElement(file_elem, "content")
                    if no_newline:
                        content = content.replace("\n", " ")
                    content_elem.text = content
                else:
                    # Add an empty content element with a skipped attribute
                    ET.SubElement(file_elem, "content", skipped="true")
</content>
      </file>
      <file name="out_md.py">
        <content>from typing import Dict, List, Any, Optional, Union


def format_markdown(data: Dict[str, List[Dict[str, Any]]], no_newline: bool, level: int = 0) -&gt; str:
    """
    Format the data as a Markdown string.

    Args:
        data: The data to format
        no_newline: Whether to remove newlines from the content
        level: The current indentation level

    Returns:
        The formatted Markdown string
    """
    result: List[str] = []
    for folder_name, entries in data.items():
        result.append(f"{'  ' * level}- **{folder_name}/**")
        for entry in entries:
            result.extend(format_markdown_entry(entry, no_newline, level + 1))
    return "\n".join(result)


def format_markdown_entry(entry: Dict[str, Any], no_newline: bool, level: int) -&gt; List[str]:
    """
    Format a single entry in the data as Markdown.

    Args:
        entry: The entry to format
        no_newline: Whether to remove newlines from the content
        level: The current indentation level

    Returns:
        A list of strings representing the formatted entry
    """
    result: List[str] = []
    for name, content in entry.items():
        if isinstance(content, list):  # It's a directory
            result.append(f"{'  ' * level}- **{name}/**")
            for sub_entry in content:
                result.extend(format_markdown_entry(
                    sub_entry, no_newline, level + 1))
        else:  # It's a file
            result.append(f"{'  ' * level}- **{name}**")
            if content is not None:
                if no_newline:
                    content = content.replace("\n", " ")
                result.append(f"{'  ' * (level + 1)}```")
                result.append(f"{'  ' * (level + 1)}{content}")
                result.append(f"{'  ' * (level + 1)}```")
            else:
                result.append(f"{'  ' * (level + 1)}`(content skipped)`")
    return result
</content>
      </file>
      <file name="cli.py">
        <content>"""
Command-line interface module for folder2file.
"""
import argparse
import os
import sys
from typing import Optional
from .config import Config, __version__


def config_from_cli() -&gt; Config:
    """
    Parse command line arguments and create a Config object.

    Returns:
        Config object with settings from command line arguments
    """
    parser = argparse.ArgumentParser(
        description="Convert folder structure to JSON, Markdown, XML, or text")
    parser.add_argument("folder_path", nargs='?', default=".",
                        help="Path to the folder to process")
    parser.add_argument("output_format", nargs='?', default="json",
                        choices=["json", "markdown", "text", "xml"],
                        help="Output format (json, markdown, text, or xml)")
    parser.add_argument("--no-newline", action="store_true", default=False,
                        help="Remove unnecessary newlines")
    parser.add_argument("--skip-binaries", action="store_true", default=True,
                        help="Skip binary file contents")
    parser.add_argument("--skip-content", action="store_true", default=False,
                        help="Skip the file contents")
    parser.add_argument("--include-hidden", action="store_true", default=False,
                        help="Include hidden files and folders")
    parser.add_argument("--no-gitignore", action="store_true", default=False,
                        help="Don't apply patterns listed in .gitignore")
    parser.add_argument("--print", action="store_true", default=False,
                        help="Print output to console")
    parser.add_argument("--out", help="Output filename")
    parser.add_argument("--version", action="store_true",
                        help="Print version information")

    args: argparse.Namespace = parser.parse_args()
    if args.version:
        print(f"folder2file version {__version__}")
        sys.exit(0)

    out_filename: Optional[str] = args.out
    if out_filename is None:
        if args.folder_path == '.':
            out_filename = os.path.basename(os.path.abspath(args.folder_path))
        else:
            out_filename = os.path.basename(args.folder_path)

    if args.output_format == 'json' and not out_filename.endswith('.json'):
        out_filename += '.json'
    elif args.output_format == 'markdown' and not out_filename.endswith('.md'):
        out_filename += '.md'
    elif args.output_format == 'text' and not out_filename.endswith('.txt'):
        out_filename += '.txt'
    elif args.output_format == 'xml' and not out_filename.endswith('.xml'):
        out_filename += '.xml'

    config: Config = Config(
        folder_path=args.folder_path,
        output_format=args.output_format,
        no_newline=args.no_newline,
        skip_binaries=args.skip_binaries,
        skip_content=args.skip_content,
        include_hidden=args.include_hidden,
        no_gitignore=args.no_gitignore,
        print_output=args.print,
        out_filename=out_filename
    )

    return config
</content>
      </file>
      <file name="gitignore_parser.py">
        <content>import collections
import os
import re

from os.path import abspath, dirname
from pathlib import Path
from typing import Reversible, Union

def handle_negation(file_path, rules: Reversible["IgnoreRule"]):
    for rule in reversed(rules):
        if rule.match(file_path):
            return not rule.negation
    return False

def parse_gitignore(full_path, base_dir=None):
    if base_dir is None:
        base_dir = dirname(full_path)
    rules = []
    with open(full_path) as ignore_file:
        counter = 0
        for line in ignore_file:
            counter += 1
            line = line.rstrip('\n')
            rule = rule_from_pattern(line, base_path=_normalize_path(base_dir),
                                     source=(full_path, counter))
            if rule:
                rules.append(rule)
    if not any(r.negation for r in rules):
        return lambda file_path: any(r.match(file_path) for r in rules)
    else:
        # We have negation rules. We can't use a simple "any" to evaluate them.
        # Later rules override earlier rules.
        return lambda file_path: handle_negation(file_path, rules)

def rule_from_pattern(pattern, base_path=None, source=None):
    """
    Take a .gitignore match pattern, such as "*.py[cod]" or "**/*.bak",
    and return an IgnoreRule suitable for matching against files and
    directories. Patterns which do not match files, such as comments
    and blank lines, will return None.
    Because git allows for nested .gitignore files, a base_path value
    is required for correct behavior. The base path should be absolute.
    """
    # Store the exact pattern for our repr and string functions
    orig_pattern = pattern
    # Early returns follow
    # Discard comments and separators
    if pattern.strip() == '' or pattern[0] == '#':
        return
    # Strip leading bang before examining double asterisks
    if pattern[0] == '!':
        negation = True
        pattern = pattern[1:]
    else:
        negation = False
    # Multi-asterisks not surrounded by slashes (or at the start/end) should
    # be treated like single-asterisks.
    pattern = re.sub(r'([^/])\*{2,}', r'\1*', pattern)
    pattern = re.sub(r'\*{2,}([^/])', r'*\1', pattern)

    # Special-casing '/', which doesn't match any files or directories
    if pattern.rstrip() == '/':
        return

    directory_only = pattern[-1] == '/'
    # A slash is a sign that we're tied to the base_path of our rule
    # set.
    anchored = '/' in pattern[:-1]
    if pattern[0] == '/':
        pattern = pattern[1:]
    if pattern[0] == '*' and len(pattern) &gt;= 2 and pattern[1] == '*':
        pattern = pattern[2:]
        anchored = False
    if pattern[0] == '/':
        pattern = pattern[1:]
    if pattern[-1] == '/':
        pattern = pattern[:-1]
    # patterns with leading hashes or exclamation marks are escaped with a
    # backslash in front, unescape it
    if pattern[0] == '\\' and pattern[1] in ('#', '!'):
        pattern = pattern[1:]
    # trailing spaces are ignored unless they are escaped with a backslash
    i = len(pattern)-1
    striptrailingspaces = True
    while i &gt; 1 and pattern[i] == ' ':
        if pattern[i-1] == '\\':
            pattern = pattern[:i-1] + pattern[i:]
            i = i - 1
            striptrailingspaces = False
        else:
            if striptrailingspaces:
                pattern = pattern[:i]
        i = i - 1
    regex = fnmatch_pathname_to_regex(
        pattern, directory_only, negation, anchored=bool(anchored)
    )
    return IgnoreRule(
        pattern=orig_pattern,
        regex=regex,
        negation=negation,
        directory_only=directory_only,
        anchored=anchored,
        base_path=_normalize_path(base_path) if base_path else None,
        source=source
    )


IGNORE_RULE_FIELDS = [
    'pattern', 'regex',  # Basic values
    'negation', 'directory_only', 'anchored',  # Behavior flags
    'base_path',  # Meaningful for gitignore-style behavior
    'source'  # (file, line) tuple for reporting
]


class IgnoreRule(collections.namedtuple('IgnoreRule_', IGNORE_RULE_FIELDS)):
    def __str__(self):
        return self.pattern

    def __repr__(self):
        return ''.join(['IgnoreRule(\'', self.pattern, '\')'])

    def match(self, abs_path: Union[str, Path]):
        matched = False
        if self.base_path:
            rel_path = str(_normalize_path(abs_path).relative_to(self.base_path))
        else:
            rel_path = str(_normalize_path(abs_path))
        # Path() strips the trailing slash, so we need to preserve it
        # in case of directory-only negation
        if self.negation and type(abs_path) == str and abs_path[-1] == '/':
            rel_path += '/'
        if rel_path.startswith('./'):
            rel_path = rel_path[2:]
        if re.search(self.regex, rel_path):
            matched = True
        return matched


# Frustratingly, python's fnmatch doesn't provide the FNM_PATHNAME
# option that .gitignore's behavior depends on.
def fnmatch_pathname_to_regex(
    pattern, directory_only: bool, negation: bool, anchored: bool = False
):
    """
    Implements fnmatch style-behavior, as though with FNM_PATHNAME flagged;
    the path separator will not match shell-style '*' and '.' wildcards.
    """
    i, n = 0, len(pattern)

    seps = [re.escape(os.sep)]
    if os.altsep is not None:
        seps.append(re.escape(os.altsep))
    seps_group = '[' + '|'.join(seps) + ']'
    nonsep = r'[^{}]'.format('|'.join(seps))

    res = []
    while i &lt; n:
        c = pattern[i]
        i += 1
        if c == '*':
            try:
                if pattern[i] == '*':
                    i += 1
                    if i &lt; n and pattern[i] == '/':
                        i += 1
                        res.append(''.join(['(.*', seps_group, ')?']))
                    else:
                        res.append('.*')
                else:
                    res.append(''.join([nonsep, '*']))
            except IndexError:
                res.append(''.join([nonsep, '*']))
        elif c == '?':
            res.append(nonsep)
        elif c == '/':
            res.append(seps_group)
        elif c == '[':
            j = i
            if j &lt; n and pattern[j] == '!':
                j += 1
            if j &lt; n and pattern[j] == ']':
                j += 1
            while j &lt; n and pattern[j] != ']':
                j += 1
            if j &gt;= n:
                res.append('\\[')
            else:
                stuff = pattern[i:j].replace('\\', '\\\\').replace('/', '')
                i = j + 1
                if stuff[0] == '!':
                    stuff = ''.join(['^', stuff[1:]])
                elif stuff[0] == '^':
                    stuff = ''.join('\\' + stuff)
                res.append('[{}]'.format(stuff))
        else:
            res.append(re.escape(c))
    if anchored:
        res.insert(0, '^')
    else:
        res.insert(0, f"(^|{seps_group})")
    if not directory_only:
        res.append('$')
    elif directory_only and negation:
        res.append('/$')
    else:
        res.append('($|\\/)')
    return ''.join(res)


def _normalize_path(path: Union[str, Path]) -&gt; Path:
    """Normalize a path without resolving symlinks.

    This is equivalent to `Path.resolve()` except that it does not resolve symlinks.
    Note that this simplifies paths by removing double slashes, `..`, `.` etc. like
    `Path.resolve()` does.
    """
    return Path(abspath(path))</content>
      </file>
      <file name="main.py">
        <content>"""
Main module for the folder2file application.
"""
from typing import Dict, Any
from .config import Config
from .folder_processor import process_folder
from .out_json import format_json
from .out_md import format_markdown
from .out_text import format_text
from .out_xml import format_xml
from .cli import config_from_cli


def main() -&gt; None:
    """
    Main entry point for the folder2file application.
    Processes a folder structure and outputs it in the specified format.
    """
    config: Config = config_from_cli()

    print("Processing folder: ", config.folder_path)
    folder_structure: Dict[str, Any] = process_folder(config).result

    print("Writing output: ", config.out_filename)
    formatted_output: str = format_output(folder_structure, config)
    if config.print_output:
        print(formatted_output)

    if config.out_filename:
        with open(config.out_filename, "w", encoding="utf-8") as f:
            f.write(formatted_output)


def format_output(data: Dict[str, Any], config: Config) -&gt; str:
    """
    Format the output data according to the specified format.

    Args:
        data: The folder structure data to format
        config: The configuration options

    Returns:
        Formatted output string

    Raises:
        ValueError: If the output format is not supported
    """
    if config.output_format == "json":
        return format_json(data, config.no_newline)
    elif config.output_format == "markdown":
        return format_markdown(data, config.no_newline)
    elif config.output_format == "text":
        return format_text(data)
    elif config.output_format == "xml":
        return format_xml(data, config.no_newline)
    else:
        raise ValueError(f"Unsupported output format: {config.output_format}")


if __name__ == "__main__":
    main()
</content>
      </file>
    </folder>
    <file name="README.md">
      <content># Folder To File

This Python-based tool converts a folder structure into JSON, Markdown, XML, or plain text format. It's designed to be modular, easy to use, and extendable for future enhancements.

## Features

- Convert folder structures to JSON, Markdown, XML, or text format
- Option to remove unnecessary newlines from file contents
- Option to skip binary files' content
- Option to skip file contents entirely
- Option to include hidden files and folders
- Option to use rules from a .gitignore file

### Local Installation

1. Ensure you have Python 3.6 or higher installed on your system.
2. Clone this repository:
   ```
   git clone https://github.com/talhaorak/folder2file.git
   cd folder2file
   ```
3. Install the package:
   ```
   pip install .
   ```

### System-wide Installation

To install the Folder Structure Converter as a system-wide application:

1. Ensure you have Python 3.6 or higher and pip installed on your system.
2. Install directly from GitHub:
   ```
   pip install git+https://github.com/talhaorak/folder2file.git
   ```

## Usage

After installation, you can run the tool from anywhere in your system using:

```
folder2file &lt;folder_path&gt; &lt;output_format&gt; [options]
```

### Arguments:

- `&lt;folder_path&gt;`: Path to the folder you want to convert (default: current directory)
- `&lt;output_format&gt;`: Choose between `json`, `markdown`, `text`, or `xml` (default: `json`)

### Options:

- `--no-newline`: Remove unnecessary newlines from file contents
- `--skip-binaries`: Don't include binary files' content, only their names
- `--skip-content`: Don't include file contents in the output (default: False)
- `--include-hidden`: Include hidden files and folders (default: False)
- `--no-gitignore`: Don't use rules from a .gitignore file (default: False)
- `--print`: Print the generated content to the console (default: False)
- `--out FILENAME`: Specify the output filename (default: name of the processed folder)
- `--version`: Show the version number and exit

### Examples:

Convert a folder to JSON, skipping binary files:
```
folder2file /path/to/your/folder json --skip-binaries
```

Convert a folder to Markdown, including hidden files and printing to console:
```
folder2file /path/to/your/folder markdown --include-hidden --print
```

Convert a folder to XML format:
```
folder2file /path/to/your/folder xml --out my_structure.xml
```

Convert a folder to JSON and save to a specific file:
```
folder2file /path/to/your/folder json --out my_structure.json
```

## Output Formats

### JSON
Produces a structured JSON representation of the folder hierarchy, with files and their contents.

### Markdown
Creates a Markdown document with folders and files represented as a nested list structure. File contents are included in code blocks.

### XML
Generates an XML document with a hierarchical representation of folders and files. File contents are enclosed in `&lt;content&gt;` tags.

### Text
Creates a simple plain text representation of the folder structure, with indentation to indicate nesting.

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## TODO

- Add support for more output formats (e.g., YAML)
- Implement file content filtering options
- Add option to limit recursion depth
- Add progress indicators for large directories

## Acknowledgments

- Thanks to [Michael Herrmann](https://github.com/mherrmann) for the [gitignore_parser](https://github.com/mherrmann/gitignore_parser) library which is used to handle .gitignore rules.

If you have any suggestions or encounter any issues, please open an issue on the GitHub repository.</content>
    </file>
    <file name="setup.py">
      <content>from setuptools import setup, find_packages
from folder2file.config import __version__

setup(
    name="folder2file",
    version=__version__,
    packages=find_packages(),
    entry_points={
        "console_scripts": [
            "folder2file=folder2file.main:main",
        ],
    },
    author="Talha Orak",
    author_email="talhaorak.git@gmail.com",
    description="A tool to convert folder structures to JSON or Markdown",
    long_description=open("README.md").read(),
    long_description_content_type="text/markdown",
    url="https://github.com/talhaorak/folder2file",
    license="MIT",
    classifiers=[
        "Programming Language :: Python :: 3",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
    ],
    python_requires="&gt;=3.6",
)
</content>
    </file>
  </folder>
</folderStructure>
